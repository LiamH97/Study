# Roadmap: From Python Scripting → Proficient Go Developer → Software Engineer

> Learn Go + design + architecture + systems together, not strictly linearly.
> Use projects as your spine: build → read → refactor → build bigger.

---

##  Phase 1: Learn Go basics
- 📕 [*Head First Go*](https://github.com/baoozuma/Head-First-All-Series-PDF/blob/main/Head%20First%20Go.pdf)
- Build small CLI tools or scripts
- Start reading:
  - *Clean Code* (first chapters)
  - *The Pragmatic Programmer* (mindset, DRY, naming)

**Goal:** Move from “I can script” → “I can write small, structured programs with modules & tests.”

---

##  Phase 2: Go deeper & get idiomatic
- 📘 *Learn Go With Tests* [Gitbook](https://quii.gitbook.io/learn-go-with-tests)
- Add concurrency, interfaces, tests
- Refactor projects applying:
  - *Clean Code* (naming, functions, comments)
  - *Pragmatic Programmer* (orthogonality, DRY)

**Goal:** Become comfortable thinking and building idiomatic Go apps.

---

##  Phase 3: Design & architecture thinking
- 📙 *Fundamentals of Software Architecture* (Richards & Ford)  
  or *Software Architecture: The Hard Parts*
- *Design Patterns Explained* (language‑agnostic)
- Refactor your apps:
  - Apply factory, strategy, adapter patterns
  - Organize into packages/modules

**Goal:** See your project as a system, not a file; design for maintainability.

---

##  Phase 4: Systems thinking & deployment
- 📗 *Designing Data‑Intensive Applications* (Martin Kleppmann)
- [*System Design Primer* ](https://github.com/donnemartin/system-design-primer/tree/master)
- Try:
  - Adding database, caching
  - Dockerizing your app
  - Basic CI/CD with GitHub Actions
- Learn deployment on Fly.io, Render, Railway

**Goal:** Move from “my app runs locally” → “it could run in production, with real data & reliability.”

---

##  Tips:
- Use each project to *practice what you read*
- Build → read → refactor → build bigger → repeat
